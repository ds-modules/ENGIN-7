
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML is auto-generated from an M-file.
To make changes, update the M-file and republish this document.
      --><title>Lab4_Solution</title><meta name="generator" content="MATLAB 7.10"><meta name="date" content="2016-02-25"><meta name="m-file" content="Lab4_Solution"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">E7 Lab 4 Solutions</a></li><li><a href="#2">Question 1</a></li><li><a href="#3">Published Test Case</a></li><li><a href="#4">Additional Test Case</a></li><li><a href="#5">Question 2</a></li><li><a href="#6">Published Test Case</a></li><li><a href="#7">Published Test Case</a></li><li><a href="#8">Additional Test Case</a></li><li><a href="#9">Additional Test Case</a></li><li><a href="#10">Question 3</a></li><li><a href="#11">Published Test Case</a></li><li><a href="#12">Published Test Case</a></li><li><a href="#13">Published Test Case</a></li><li><a href="#14">Additional Test Case</a></li><li><a href="#15">Additional Test Case</a></li><li><a href="#16">Question 4</a></li><li><a href="#17">Published Test Case</a></li><li><a href="#18">Additional Test Case</a></li><li><a href="#19">Plotting Path</a></li><li><a href="#20">Question 5a</a></li><li><a href="#21">Published Test Case</a></li><li><a href="#22">Published Test Case</a></li><li><a href="#23">Additional Test Case</a></li><li><a href="#24">Question 5b</a></li><li><a href="#25">Published Test Case</a></li><li><a href="#26">Published Test Case</a></li><li><a href="#27">Additional Test Case</a></li><li><a href="#28">Question 5c</a></li><li><a href="#29">Published Test Case</a></li><li><a href="#30">Additional Test Case</a></li><li><a href="#31">Additional Test Case</a></li><li><a href="#32">Compare Computation Time Between Recursive &amp; Iterative Functions</a></li><li><a href="#33">Question 5d</a></li><li><a href="#34">Published Test Case</a></li><li><a href="#35">Published Test Case</a></li><li><a href="#36">Additional Test Case</a></li><li><a href="#37">Question 6</a></li><li><a href="#38">Published Test Case</a></li><li><a href="#39">Published Test Case</a></li><li><a href="#40">Additional Test Case</a></li><li><a href="#41">How many guesses does it take?</a></li></ul></div><h2>E7 Lab 4 Solutions<a name="1"></a></h2><p>Spring 2016</p><pre class="codeinput">format <span class="string">compact</span>
format <span class="string">short</span>
clear <span class="string">all</span>
clc
close <span class="string">all</span>
</pre><h2>Question 1<a name="2"></a></h2><pre class="codeinput">type <span class="string">mySavingsPlan</span>
</pre><pre class="codeoutput">
function [years] = mySavingsPlan(P0,rate,goal)
% P0 and goal are assumed to be positive doubles representing 
% respectively the initial investment and the investment goal.
% rate is assumed to be a double between 0 and 1, 
% representing the constant yearly interest rate.
% The investment balance is assumed to be updated once per year. 
% Therefore the function outputs a whole number, the scalar double years. 

if P0&gt;=goal
    % initial condition: when P0 exceeds goal, the recursion is over 
    % and no additional compounding period is needed
    years=0;
else
    % recursion relationship: when P0 is smaller than goal, years is
    % incremented by one and we call the function with an initial
    % investment updated by the interest rate
    years=1+mySavingsPlan(P0*(1+rate),rate,goal);  
end
end
</pre><h2>Published Test Case<a name="3"></a></h2><pre class="codeinput">years = mySavingsPlan(2000, 0.15, 10000)
</pre><pre class="codeoutput">years =
    12
</pre><h2>Additional Test Case<a name="4"></a></h2><pre class="codeinput">years = mySavingsPlan(1000, 0.05, 10000)
</pre><pre class="codeoutput">years =
    48
</pre><h2>Question 2<a name="5"></a></h2><pre class="codeinput">type <span class="string">myMin</span>
</pre><pre class="codeoutput">
function [value, location] = myMin(P)
% P is assumed to be a double array. 
% The function returns two outputs: value is equal to the minimum 
% value stored in P; location is either a scalar equal to the index of 
% the minimum if this minimum is unique, or a row vector containing 
% several indices if this minimum appears several times in the array P

% initial condition: by default, the minimum is the first element of P
value=P(1); 
location=1;
for i = 2:length(P) % loop over all elements in P
    if P(i)&lt;value 
        % if a new unique minimum is found, update value and location
        value=P(i);
        location=i;
    elseif P(i)==value 
        % if an element is equal to the current minimum, 
        % location becomes a row array
        location=[location, i];
    end
end
end
</pre><h2>Published Test Case<a name="6"></a></h2><pre class="codeinput">[value, location] = myMin([5 4 5 2 6 7 1 8 9])
</pre><pre class="codeoutput">value =
     1
location =
     7
</pre><h2>Published Test Case<a name="7"></a></h2><pre class="codeinput">[value, location] = myMin([2 3 5 7 2 4 3 2])
</pre><pre class="codeoutput">value =
     2
location =
     1     5     8
</pre><h2>Additional Test Case<a name="8"></a></h2><pre class="codeinput">[value, location] = myMin([2 -3 5 -7 2 4 3 2])
</pre><pre class="codeoutput">value =
    -7
location =
     4
</pre><h2>Additional Test Case<a name="9"></a></h2><pre class="codeinput">[value, location] = myMin([2 -3 5 7 2 4 -3 2])
</pre><pre class="codeoutput">value =
    -3
location =
     2     7
</pre><h2>Question 3<a name="10"></a></h2><pre class="codeinput">type <span class="string">myRainfall</span>
</pre><pre class="codeoutput">
function [rainTot, rainAvg] = myRainfall(rainData)
% rainData is assumed to be a double array. It can contain
% positive numbers, negative numbers or the specific value -999.
% If it exists, the first occurence of -999 in rainData delimits 
% the end of the period of interest.
% A negative value represents an erroneous measurement and 
% is not included in the computation of rainTot and rainAvg. 
% The function returns two outputs: rainTot is a double representing the
% total amount of rainfall, rainAvg is a double representing its 
% average over the period.

rainTot=0; % initialize the total rainfall
count_days=0; 
% count_days helps keeping track of how many days should be taken
% into account to calculate the average rainfall 
n=1; % dummy variable used to navigate rainData
while  n&lt;=length(rainData) &amp;&amp; rainData(n)~=-999 
    % the function stops going through rainData when the first -999 
    % is encountered; if none exists, it goes until the end
    if rainData(n)&gt;=0 % exclude negative data (erroneous measurements)
        rainTot=rainTot+rainData(n); 
        % update the total rainfall
        count_days=count_days+1; 
        % update the total of "actual" days of measurements
    end
    n=n+1; % go to next element in the array
end
rainAvg=rainTot/count_days; % compute the average      
end
</pre><h2>Published Test Case<a name="11"></a></h2><pre class="codeinput">[rainTot, rainAvg] = myRainfall([2,4,-5,1,7,-2,8,-999,4,6,4])
</pre><pre class="codeoutput">rainTot =
    22
rainAvg =
    4.4000
</pre><h2>Published Test Case<a name="12"></a></h2><pre class="codeinput">[rainTot, rainAvg] = myRainfall([2,4,-5,1,7,-2,8,0,4,6,4])
</pre><pre class="codeoutput">rainTot =
    36
rainAvg =
     4
</pre><h2>Published Test Case<a name="13"></a></h2><pre class="codeinput">[rainTot, rainAvg] = myRainfall([2,4,-999,1,7,-2,8,-999,4,6,4])
</pre><pre class="codeoutput">rainTot =
     6
rainAvg =
     3
</pre><h2>Additional Test Case<a name="14"></a></h2><pre class="codeinput">[rainTot, rainAvg] = myRainfall([2.3,4.1,-5.4,1.0,7.1,-2,8.0,4.9,6,-999])
</pre><pre class="codeoutput">rainTot =
   33.4000
rainAvg =
    4.7714
</pre><h2>Additional Test Case<a name="15"></a></h2><pre class="codeinput">[rainTot, rainAvg] = myRainfall([0,-999,-5,1,7,-2,8,-999,4,6,2])
</pre><pre class="codeoutput">rainTot =
     0
rainAvg =
     0
</pre><h2>Question 4<a name="16"></a></h2><pre class="codeinput">type <span class="string">RandomWalk</span>
</pre><pre class="codeoutput">
%RandomWalk - Returns the random path of a vacuum cleaner robot that
%wanders around a closed room
%
%   [N,path] = RandomWalk(L,rmat) returns N, the number of steps, and path,
%   an (N+1)x2 matrix of path coordinates that the robot took to clean the
%   entire L'xL' square room according to rmat, a matrix of random integers
%   from 1 to 4 that determines the "random" movement (defined below) of 
%   the robot.
%   
%       rmat determines the direction and length of each step.
%       - rmat has M rows
%       - each row of rmat is one step
%       - the first column determines the direction
%               1:  up   (+y)
%               2: down  (-y)
%               3: right (+x)
%               4: left  (-x)
%       - the second column determines the length

function [N, path] = RandomWalk(L,rmat)
room = zeros(L+1);      %matrix of room coordinates (all not cleaned)
                        %room is defined such that room(x,y) is [x-1,y-1]
                        %in cartesian coordinates
                        
x = 1;                  %robot starts at the cartesian coordinate (0,0)                   
y = 1;                  %which is location (1,1) in room matrix

room(x,y) = 1;          %set room position to be 1 when it is cleaned
                        %robot has cleaned its starting position

rmat_ind = 1;           %initialize starting rmat index
N = 0;                  %initialize number of steps counter
path = [0,0];           %initialize path taken matrix

while ~all(all(room))                   %stop when every coordinate is 1
    
    if rmat_ind &gt; size(rmat,1)          %check if index in rmat exceeded
        rmat_ind = 1;                   %if it is, reset index to 1
    end
    
    while isWall(x,y,rmat,rmat_ind,L)   %check if robot hits wall
        rmat_ind = rmat_ind + 1;        %if hits wall, increment index
        
        if rmat_ind &gt; size(rmat,1)      %re-check if index in rmat exceeded
            rmat_ind = 1;
        end
    end
    
    %switch statement determines which direction to go according to the
    %current row and the first column of rmat
    %       switch (rmat(current row, first column))
    %           case (each of the 1 to 4 possibilities given in table)
    %               %sets coordinates robot wanders over to 1 (now cleaned)
    %               %changes index to new current location
    switch rmat(rmat_ind,1)                        
        case 1
            room(x,y:y+rmat(rmat_ind,2)) = 1;      
            y = y + rmat(rmat_ind,2);              
        case 2
            room(x,y:-1:y-rmat(rmat_ind,2)) = 1;
            y = y - rmat(rmat_ind,2);
        case 3
            room(x:x+rmat(rmat_ind,2),y) = 1;
            x = x + rmat(rmat_ind,2);
        case 4
            room(x:-1:x-rmat(rmat_ind,2),y) = 1;
            x = x - rmat(rmat_ind,2);
    end

    rmat_ind = rmat_ind + 1;        %increments to next row in rmat
    path = [path; x-1, y-1];        %adds current cartesian coordinate to
                                    %output path
    N = N + 1;                      %increments current steps taken
end
    
end


%isWall - Checks if the robot hits a wall
%
%   check = isWall(x,y,rmat,rmat_ind,L) returns a boolean 1 if the robot
%   hits a wall (x or y ends up outside of the L'xL' room) if the current
%   step, rmat(rmat_ind), is taken. Returns boolean 0 if it does not hit.

function check = isWall(x,y,rmat,rmat_ind,L)

switch rmat(rmat_ind,1)
    case 1
        check = (y+rmat(rmat_ind,2)) &gt; L+1;
    case 2
        check = (y-rmat(rmat_ind,2)) &lt; 1;
    case 3
        check = (x+rmat(rmat_ind,2)) &gt; L+1;
    case 4
        check = (x-rmat(rmat_ind,2)) &lt; 1;
end
end
</pre><h2>Published Test Case<a name="17"></a></h2><pre class="codeinput">rmat = [4 1;1 2;3 2;1 1;4 1; 2 1; 2 2; 3 1; 1 1 ;2 2];
[N, path] = RandomWalk(2,rmat)
</pre><pre class="codeoutput">N =
     8
path =
     0     0
     0     2
     2     2
     1     2
     1     1
     2     1
     2     2
     2     0
     1     0
</pre><h2>Additional Test Case<a name="18"></a></h2><h2>Plotting Path<a name="19"></a></h2><pre class="codeinput">rmat = randi([1 4], 300, 2);
[N, path] = RandomWalk(5, rmat);
N
plot(path(:,1), path(:,2), <span class="string">'-o'</span>)
</pre><pre class="codeoutput">N =
    60
</pre><img vspace="5" hspace="5" src="Lab4_Solution_01.png" alt=""> <h2>Question 5a<a name="20"></a></h2><pre class="codeinput">type <span class="string">FibRec</span>
</pre><pre class="codeoutput">
% FibRec - Returns the Nth number in Fibonacci sequence
%
%   F = FibRec(N) returns the Nth number of the Fibonacci sequence using
%   recursion.
function F = FibRec(N)
if N &lt; 1            %input N is not a positive integer, return an error msg
    F = 'N must be a positive integer';
elseif N == 1       %base case 1
    F = 0;
elseif N == 2       %base case 2
    F = 1;
else
    F = FibRec(N-1) + FibRec(N-2);      %Fibonacci is sum of previous two 
                                        %Fibonacci elements
end
end
</pre><h2>Published Test Case<a name="21"></a></h2><pre class="codeinput">F = FibRec(12)
</pre><pre class="codeoutput">F =
    89
</pre><h2>Published Test Case<a name="22"></a></h2><pre class="codeinput">F = FibRec(-3)
</pre><pre class="codeoutput">F =
N must be a positive integer
</pre><h2>Additional Test Case<a name="23"></a></h2><pre class="codeinput">F = FibRec(23)
</pre><pre class="codeoutput">F =
       17711
</pre><h2>Question 5b<a name="24"></a></h2><pre class="codeinput">type <span class="string">FibIter</span>
</pre><pre class="codeoutput">
% FibIter - Returns the Nth number in Fibonacci sequence
%
%   F = FibRec(N) returns the Nth number of the Fibonacci sequence using a
%   for loop

function F = FibIter(N)
f1 = 0;            %initialize first element
f2 = 1;            %initialize second element

if N &lt; 1           %input N is not a positive integer, return an error msg
    F = 'N must be a positive integer';
elseif N == 1 || N == 2
    F = 1;
else
    for n = 3:N
        F = f1 + f2;        %Fibonacci number is the sum of previous two
                            %Fibonacci numbers
        f1 = f2;
        f2 = F;
    end
end

end
    
</pre><h2>Published Test Case<a name="25"></a></h2><pre class="codeinput">F = FibIter(12)
</pre><pre class="codeoutput">F =
    89
</pre><h2>Published Test Case<a name="26"></a></h2><pre class="codeinput">F = FibIter(0)
</pre><pre class="codeoutput">F =
N must be a positive integer
</pre><h2>Additional Test Case<a name="27"></a></h2><pre class="codeinput">F = FibIter(6)
</pre><pre class="codeoutput">F =
     5
</pre><h2>Question 5c<a name="28"></a></h2><pre class="codeinput">type <span class="string">FibRatio</span>
</pre><pre class="codeoutput">
% FibRatio - Returns the approximated golden ratio
%
%   r = FibRatio(N) returns the ratio, r, of Nth / (N-1)th value of the
%   Fibonacci sequence

function r = FibRatio(N)
if N &lt; 2
    r = 'N must be an integer greater than 1';
else
    r = FibRec(N)/FibRec(N-1);
end
end
</pre><h2>Published Test Case<a name="29"></a></h2><pre class="codeinput">r = FibRatio(10)
</pre><pre class="codeoutput">r =
    1.6190
</pre><h2>Additional Test Case<a name="30"></a></h2><pre class="codeinput">r = FibRatio(1)
</pre><pre class="codeoutput">r =
N must be an integer greater than 1
</pre><h2>Additional Test Case<a name="31"></a></h2><pre class="codeinput">r = FibRatio(15)
</pre><pre class="codeoutput">r =
    1.6180
</pre><h2>Compare Computation Time Between Recursive &amp; Iterative Functions<a name="32"></a></h2><pre class="codeinput">n_array = 1:2:21; <span class="comment">% array of n values to compute Fib sequence</span>
t_rec = zeros(size(n_array)); <span class="comment">% initialize array to store comp times</span>
t_iter = zeros(size(n_array)); <span class="comment">% store comp times for iterative fxn</span>
<span class="keyword">for</span> q = 1:numel(n_array) <span class="comment">% loop through all values for n</span>
    tic
    F = FibRec( n_array(q) );
    t_rec(q) = toc ;
    tic
    F = FibIter( n_array(q) );
    t_iter(q) = toc ;
<span class="keyword">end</span>
plot(n_array, t_rec, <span class="string">'r-*'</span>, n_array, t_iter, <span class="string">'g-o'</span>)
xlabel(<span class="string">'N'</span>); ylabel(<span class="string">'computation time (seconds)'</span>)
legend(<span class="string">'recursive'</span>, <span class="string">'iterative'</span>, <span class="string">'location'</span>, <span class="string">'northwest'</span>)
</pre><img vspace="5" hspace="5" src="Lab4_Solution_02.png" alt=""> <h2>Question 5d<a name="33"></a></h2><pre class="codeinput">type <span class="string">FibApprox</span>
</pre><pre class="codeoutput">
%FibApprox - Returns the smallest integer, N, such that FibRatio(N)
%converges to the exact value of the Golden Ratio
%
%   N = FibApprox(e) returns the smallest integer, N, such that 
%   abs(phi - FibRatio(N)) &lt; e

function N = FibApprox(e)
phi = (1+sqrt(5))/2;
N = 2;

while abs(phi - FibRatio(N)) &gt; e
    N = N + 1;
end
end
</pre><h2>Published Test Case<a name="34"></a></h2><pre class="codeinput">N = FibApprox(1e-6)
</pre><pre class="codeoutput">N =
    18
</pre><h2>Published Test Case<a name="35"></a></h2><pre class="codeinput">N = FibApprox(1e-8)
</pre><pre class="codeoutput">N =
    22
</pre><h2>Additional Test Case<a name="36"></a></h2><pre class="codeinput">N = FibApprox(1e-4)
</pre><pre class="codeoutput">N =
    13
</pre><h2>Question 6<a name="37"></a></h2><pre class="codeinput">type <span class="string">player2</span>
</pre><pre class="codeoutput">
function [N_guess] = player2(nmin, nmax, N_guess, secret)
N_guess = N_guess + 1;
guess = round((nmax+nmin)/2);
[msg] = player1response( guess , secret);

if( strcmp( msg, 'higher'))
    N_guess = player2(guess, nmax, N_guess, secret);   
elseif( strcmp(msg, 'lower'))
    N_guess = player2(nmin, guess, N_guess, secret);   
end    
   
end

   
</pre><h2>Published Test Case<a name="38"></a></h2><pre class="codeinput">N_guess = player2(10, 20, 0, player1initialize(10, 20) )
</pre><pre class="codeoutput">Guess a number between 10 and 20
the secret number is lower than your guess of 15 
the secret number is lower than your guess of 13 
you guessed the secret number, which is 12 
N_guess =
     3
</pre><h2>Published Test Case<a name="39"></a></h2><pre class="codeinput">N_guess = player2(0, 30, 0, player1initialize(0, 30) )
</pre><pre class="codeoutput">Guess a number between 0 and 30
the secret number is higher than your guess of 15 
the secret number is higher than your guess of 23 
the secret number is higher than your guess of 27 
the secret number is lower than your guess of 29 
you guessed the secret number, which is 28 
N_guess =
     5
</pre><h2>Additional Test Case<a name="40"></a></h2><pre class="codeinput">N_guess = player2(13, 157, 0, player1initialize(13, 157) )
</pre><pre class="codeoutput">Guess a number between 13 and 157
the secret number is higher than your guess of 85 
the secret number is higher than your guess of 121 
the secret number is higher than your guess of 139 
you guessed the secret number, which is 148 
N_guess =
     4
</pre><h2>How many guesses does it take?<a name="41"></a></h2><pre class="codeinput">N_possibilities = 5:5:100; <span class="comment">% array of range sizes</span>
N_guess_array1 = zeros(size(N_possibilities));
N_guess_array5 = zeros(size(N_possibilities));
N_guess_array50 = zeros(size(N_possibilities));
<span class="keyword">for</span> q1 = 1:numel(N_possibilities)
    nmin = 0;
    nmax = N_possibilities(q1) - 1;
    N_tmp = zeros(1,50); <span class="comment">% repeat many times and take the average</span>

    <span class="keyword">for</span> q2 = 1:numel(N_tmp)
        N_tmp(q2) = player2quiet(nmin,nmax,0, player1qinitialize(nmin,nmax));
        <span class="comment">% player2quiet is a modified version of player2 that prints nothing</span>
        <span class="comment">% to screen (otherwise these solutions would be &gt;100 pages!)</span>
        <span class="comment">% it also uses modified versions of the player 1 functions which</span>
        <span class="comment">% also don't have fprintf statements</span>
    <span class="keyword">end</span>
    N_guess_array50(q1) = mean(N_tmp); <span class="comment">% take avg of all 50 trials</span>
    N_guess_array5(q1) = mean(N_tmp(1:5)); <span class="comment">% take avg of only 5 trials</span>
    N_guess_array1(q1) = N_tmp(1); <span class="comment">% take only 1 trial</span>
<span class="keyword">end</span>

plot(N_possibilities, N_guess_array5, <span class="string">'r-o'</span>, N_possibilities, <span class="keyword">...</span>
    N_guess_array50, <span class="string">'g-*'</span>, N_possibilities, N_guess_array1, <span class="string">'k-x'</span>,<span class="keyword">...</span>
    N_possibilities, log2(N_possibilities)+1, <span class="string">'b-.'</span>)
legend(<span class="string">'avg of 5 trials'</span>, <span class="string">'avg of 50 trials'</span>, <span class="string">'1 trial'</span>,<span class="string">'log2(N)+1'</span>,<span class="keyword">...</span>
    <span class="string">'location'</span>,<span class="string">'northwest'</span>)
</pre><img vspace="5" hspace="5" src="Lab4_Solution_03.png" alt=""> <p class="footer"><br>
      Published with MATLAB&reg; 7.10<br></p></div><!--
##### SOURCE BEGIN #####
%% E7 Lab 4 Solutions
% Spring 2016
format compact
format short
clear all
clc
close all

%% Question 1
type mySavingsPlan


%% Published Test Case
years = mySavingsPlan(2000, 0.15, 10000)

%% Additional Test Case
years = mySavingsPlan(1000, 0.05, 10000)

%% Question 2
type myMin

%% Published Test Case
[value, location] = myMin([5 4 5 2 6 7 1 8 9])

%% Published Test Case
[value, location] = myMin([2 3 5 7 2 4 3 2])

%% Additional Test Case
[value, location] = myMin([2 -3 5 -7 2 4 3 2])

%% Additional Test Case
[value, location] = myMin([2 -3 5 7 2 4 -3 2])

%% Question 3
type myRainfall

%% Published Test Case
[rainTot, rainAvg] = myRainfall([2,4,-5,1,7,-2,8,-999,4,6,4])

%% Published Test Case
[rainTot, rainAvg] = myRainfall([2,4,-5,1,7,-2,8,0,4,6,4])

%% Published Test Case
[rainTot, rainAvg] = myRainfall([2,4,-999,1,7,-2,8,-999,4,6,4])

%% Additional Test Case
[rainTot, rainAvg] = myRainfall([2.3,4.1,-5.4,1.0,7.1,-2,8.0,4.9,6,-999])

%% Additional Test Case
[rainTot, rainAvg] = myRainfall([0,-999,-5,1,7,-2,8,-999,4,6,2])

%% Question 4
type RandomWalk

%% Published Test Case
rmat = [4 1;1 2;3 2;1 1;4 1; 2 1; 2 2; 3 1; 1 1 ;2 2];
[N, path] = RandomWalk(2,rmat)

%% Additional Test Case

%% Plotting Path
rmat = randi([1 4], 300, 2);
[N, path] = RandomWalk(5, rmat);
N
plot(path(:,1), path(:,2), '-o')


%% Question 5a
type FibRec

%% Published Test Case
F = FibRec(12)

%% Published Test Case
F = FibRec(-3)

%% Additional Test Case
F = FibRec(23)

%% Question 5b
type FibIter

%% Published Test Case
F = FibIter(12)

%% Published Test Case
F = FibIter(0)

%% Additional Test Case
F = FibIter(6)

%% Question 5c
type FibRatio

%% Published Test Case
r = FibRatio(10)

%% Additional Test Case
r = FibRatio(1)

%% Additional Test Case
r = FibRatio(15)

%% Compare Computation Time Between Recursive & Iterative Functions
n_array = 1:2:21; % array of n values to compute Fib sequence
t_rec = zeros(size(n_array)); % initialize array to store comp times
t_iter = zeros(size(n_array)); % store comp times for iterative fxn
for q = 1:numel(n_array) % loop through all values for n
    tic
    F = FibRec( n_array(q) ); 
    t_rec(q) = toc ;
    tic
    F = FibIter( n_array(q) );
    t_iter(q) = toc ;
end
plot(n_array, t_rec, 'r-*', n_array, t_iter, 'g-o')
xlabel('N'); ylabel('computation time (seconds)')
legend('recursive', 'iterative', 'location', 'northwest')

%% Question 5d
type FibApprox

%% Published Test Case
N = FibApprox(1e-6)

%% Published Test Case
N = FibApprox(1e-8)

%% Additional Test Case
N = FibApprox(1e-4)

%% Question 6
type player2

%% Published Test Case
N_guess = player2(10, 20, 0, player1initialize(10, 20) )

%% Published Test Case
N_guess = player2(0, 30, 0, player1initialize(0, 30) )

%% Additional Test Case
N_guess = player2(13, 157, 0, player1initialize(13, 157) )

%% How many guesses does it take? 
N_possibilities = 5:5:100; % array of range sizes
N_guess_array1 = zeros(size(N_possibilities));
N_guess_array5 = zeros(size(N_possibilities)); 
N_guess_array50 = zeros(size(N_possibilities));
for q1 = 1:numel(N_possibilities)
    nmin = 0;
    nmax = N_possibilities(q1) - 1;
    N_tmp = zeros(1,50); % repeat many times and take the average
    
    for q2 = 1:numel(N_tmp)
        N_tmp(q2) = player2quiet(nmin,nmax,0, player1qinitialize(nmin,nmax));
        % player2quiet is a modified version of player2 that prints nothing
        % to screen (otherwise these solutions would be >100 pages!)
        % it also uses modified versions of the player 1 functions which
        % also don't have fprintf statements
    end
    N_guess_array50(q1) = mean(N_tmp); % take avg of all 50 trials
    N_guess_array5(q1) = mean(N_tmp(1:5)); % take avg of only 5 trials
    N_guess_array1(q1) = N_tmp(1); % take only 1 trial
end

plot(N_possibilities, N_guess_array5, 'r-o', N_possibilities, ...
    N_guess_array50, 'g-*', N_possibilities, N_guess_array1, 'k-x',...
    N_possibilities, log2(N_possibilities)+1, 'b-.')
legend('avg of 5 trials', 'avg of 50 trials', '1 trial','log2(N)+1',...
    'location','northwest')



##### SOURCE END #####
--></body></html>